#include "sPlcMcu.h"
/*****************************************************************************/
static data uint8_t sPlcInterrupt;
/*****************************************************************************/
uint8_t floatSumTest(void){
	uint32_t i;
	fp64_t f = 0.1;
	fp64_t sum = 0;
	for(i=0; i<400000; i++){
		sum += f;
	}
	if(sum >= 40020.8F && sum <= 40020.9){
		return true;
	}
	else{
		return false;
	}
}

void initWatchDog(void){//看门狗初始化
	WDTCN = 0x07;//47mS
}
void enableWatchDog(void){//使能看门狗
#if CONFIG_SPLC_USING_WDT == 1
	WDTCN = 0xA5;
#endif
}
void disableWatchDog(void){//关闭看门狗(未锁定)
	uint8_t flagEA;
	flagEA = EA;
	EA = 0;
	WDTCN = 0xDE;
    WDTCN = 0xAD;
	EA = flagEA;
}
void feedWatchDog(void) {//喂狗
#if CONFIG_SPLC_USING_WDT == 1
	WDTCN = 0xA5;
#endif
}
void mucReboot(void)  {//复位
	RSTSRC |= 1 << 4;//Forces a Power-On Reset. RST is driven low.
}
void enterSplcIsr(void) {//SPLC 进入中断
	sPlcInterrupt = EA;
	EA = false;
}
void exitSplcIsr(void) {//SPLC 退出中断
	EA = sPlcInterrupt;
}
void disableSplcIsr(void) {//SPLC关闭全局中断
	EA = 0;
}
void enableSplcIsr(void) {//SPLC打开全局中断
	EA = 1;
}
void disalbeModbusSerialIsr(void){
	ES0 = 0;
}
void enableModbusSerialIsr(void){
	ES0 = 1;
}

//-----------------------------------------------------------------------------
// Cache_ISR_Entry
//-----------------------------------------------------------------------------
//
// This routine pushes and locks an interrupt vector and the first one or two
// 4-byte FLASH segments of an ISR entry point into the cache. 
//
void Cache_ISR_Entry(unsigned int start_address, unsigned int interrupt_number){
   char SFRPAGE_SAVE = SFRPAGE;        // Preserve current SFR page
   char EA_SAVE = EA;                  // Preserve interrupt state

   unsigned char code* pread;          // Pointer used to generate MOVC 
                                       // instructions to initiate a cache
                                       // push operation
   unsigned char temp_char;            // Temporary char.

   // Set the <pread> pointer to the address of the interrupt vector.
   pread = ((interrupt_number * 8) + 3 ); 
   

   SFRPAGE = CONFIG_PAGE;              // Set SFR page

   EA = 0;                             // Disable Interrupts

   CCH0LC &= ~0xC0;                    // Clear the CHPUSH and CHPOP bits
   CCH0LC |=  0x80;                    // Enable cache pushes, MOVC instructions
                                       // will push 4-byte FLASH segments into
                                       // the cache
                                       
   // Check if there is enough room to cache the interrupt vector and the first
   // two 4-byte segments of the ISR entry point.  When the two (or one) slot(s)
   // required to cache the ISR entry point and the two slots needed to cache the
   // interrupt vector (Total 4 slots) are subtracted from the CHSLOT pointer,
   // the result is the number of unlocked slots available.
   if( ((CCH0LC & 0x3F) - 4) <= 0 ){
      while(1);                        // Handle Error Condition.
                                       // Not enough room to cache ISR Entry Point
   }    
   
   // Push the interrupt vector in the cache slot pointed to by CHSLOT.
   // An interrupt vector generated by the KEIL C51 compiler consists of a
   // 3-byte LJMP instruction. Since the LSBs of an interrupt vector address are 
   // always 10b, the first two bytes of the LJMP instruction fall in the first
   // 4-byte FLASH segment and the remaining byte of the instruction falls in the
   // second 4-byte segment.  Two cache pushes are neccessary.
   
   temp_char = *pread;                 // Push the first 4-byte segment (MOVC)
   temp_char = *(pread + 4);           // Push the second 4-byte segment (MOVC)

   // If the first byte of the ISR is aligned on a multiple of 4 (i.e. the LSBs
   // of the first byte are 00b), then cache the first 4-byte segment. Otherwise,
   // cache the first two 4-byte segments.
   pread = (unsigned char code*) start_address;
                                       // Set <pread> to the address of the
                                       // interrupt service routine.
   
   temp_char = *pread;                 // Push the first 4-byte segment (MOVC)
      
   if(start_address & 0x03){
      temp_char = *(pread + 4);        // Push the second 4-byte segment (MOVC)
   }                                   // if the two LSBs of <start_address>
                                       // are not zero

   CCH0LC &= ~0x80;                    // Clear CHPUSH to disable cache pushes.
   SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page.
   EA = EA_SAVE;                       // Restore interrupt state.

}